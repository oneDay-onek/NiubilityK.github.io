<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js运行机制]]></title>
    <url>%2F2019%2F09%2F25%2Fjs%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[以下是主线程和任务队列的关系示意图： st=>start: 主线程上的同步任务执行栈执行完成 op=>operation: 检查任务队列中的事件 op1=>operation: 执行任务队列中的事件 cond=>condition: 任务队列中是否存在事件？ sub1=>subroutine: 事件队列 st->op->cond(no)->op1->op cond(yes)->op op->sub1{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>js基础</tag>
        <tag>js事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue父子组件之间传值]]></title>
    <url>%2F2019%2F09%2F23%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[vue父子组件之间传值在个人的vue项目实际开发中，不会常遇到父子组件传值的情况，即使涉及到也会使用vuex或者webStorage来解决。但当随着工作不断深入和开展，普通的vue项目书写方式不足以应对稍大型的或者有许多复用型组件的项目，编写一个vue组件库成了当下或者日后的一个比较好的选择，尤其是UI组件。但是编写vue组件库的基本功就是基于父子组件传值来进行开发的。 vue组件之间传值只可由父传向子，不能由子传向父。 父子组件传值的形式如下。 在vue项目中新建两个.vue文件。 1234567891011121314151617&lt;!-- 此为父组件的写法 --&gt;&lt;template&gt; &lt;!-- 此处使用“：(v-on)”方式绑定的为传到子组件的值，“@(v-bind)”方式绑定的为传到子组件并可供其调用的方法。 --&gt; &lt;child :childData = &quot;fatherData&quot; @changeData = &quot;changeData&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt; data()&#123; return &#123; fatherData:&apos;word&apos;, &#125; &#125;, methods:&#123; changeData(str)&#123; this.fatherData = str; &#125; &#125;&lt;/script&gt; 另一个vue文件用来写 123456789101112131415161718192021222324&lt;!-- 此为子组件的写法 --&gt;&lt;template&gt; &lt;div&gt; &#123;&#123; cData &#125;&#125; &lt;br /&gt; &lt;button @click = &quot;setData&quot;&gt;change data to &quot;Hello World!&quot;&lt;button&gt; &lt;/div&gt;&lt;/tamplate&gt;&lt;script&gt; props:[&apos;childData&apos;], computed:&#123; /* 此处可以不声明，this.childData也可直接获传父组件来的值，只不过再有这样一层计算属性的包装可以省去对子组件中用来接收父组件值的变量的修改。*/ cData()&#123; return childData; &#125; &#125;, methods:&#123; /* 此方法为子组件中声明的方法，再调用vue定义的$emit即可调用父组件传过来的方法。 */ setData()&#123; this.$emit(&apos;changeData&apos;,&apos;Hello World!&apos;); &#125; &#125;&lt;/script&gt; 子组件调用父组件方法以传值或操作父组件变量。其中子组件中的setData()方法调用的就是父组件中的changeData()方法。在子组件调用父组件方法的写法为：this.$emit([functionName],[params])。 父组件的值在子组件可以显示但不能做更改，但是借由this.$emit就可以达到操作父元素变量的操作，或者传值到父组件。]]></content>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>vue组件传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router路由传参]]></title>
    <url>%2F2019%2F09%2F23%2Fvue-router%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[vue-router路由传参 *tip:在vue项目中，有时会有出现 连续路由都用到同一或同一些数据的情况出现，此时使用vue-router进行传参是可行的。 vue-router传参的方式分为两种： params传参：参数透明，但刷新页面会丢失数据。 query传参：参数在url之后，但刷新页面不会丢失数据。 1、配置router.js1234567891011121314export default new Router(&#123; routes:[ &#123; path:&apos;/pageFrom&apos;, name:&apos;pageFrom&apos;, component:()=&gt;import ... &#125;, &#123; path:&apos;/pageTO&apos;, name:&apos;pageTo&apos;, component:()=&gt;import ... &#125; ]&#125;); 2、使用1）params传参传递参数：使用$router 123456789101112131415161718192021222324&lt;!-- pageFrom 页面 --&gt;&lt;template&gt; &lt;button @click=&quot;&quot;&gt;Go next page&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default&#123; methods:&#123; goNextPage()&#123; /** *使用params传参时，push()方法传的是路由的name而不是path。 *params 对象用材存放需要传的值。 *params 对象中的数据是透明的，但是在刷新页面后数据会丢失。 */ this.$router.push(&#123; name:&quot;pageTo&quot;, params:&#123; id:1, name:&quot;Abbott&quot; &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt; 接收参数：使用$route 1234567891011121314151617181920212223242526272829303132&lt;!-- pageTo 页面 --&gt;&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; data()&#123; return &#123; id:&quot;&quot;, name:&quot;&quot; &#125; &#125;, methods:&#123; getData()&#123; /** *接收params传参时，传递的参数全部储存在this.$toute.params中 *直接使用传过来的参数名获取值 */ this.id = this.$route.params.id; this.name = this.$route.params.name; console.log(`id:$&#123; this.id &#125;`); // =&gt; 1 console.log(`name:$&#123; this.name &#125;`); // =&gt; &apos;Abbott&apos; &#125; &#125;, created()&#123; this.getData(); &#125;&#125;&lt;/script&gt; 2）query传参传递参数：使用$router 123456789101112131415161718192021222324&lt;!-- pageFrom 页面 --&gt;&lt;template&gt; &lt;button @click=&quot;&quot;&gt;Go next page&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default&#123; methods:&#123; goNextPage()&#123; /** *使用query传参时，push()方法传的可以是路由的name或者path。 *query 对象用材存放需要传的值。 *query 对象中的数据不是透明的，会在url之后存放，而且刷新页面不会丢失数据，仍可获取到。 */ this.$router.push(&#123; name:&quot;pageTo&quot;, query:&#123; id:1, name:&quot;Abbott&quot; &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt; 接收参数：使用$route 1234567891011121314151617181920212223242526272829303132&lt;!-- pageTo 页面 --&gt;&lt;template&gt; &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; data()&#123; return &#123; id:&quot;&quot;, name:&quot;&quot; &#125; &#125;, methods:&#123; getData()&#123; /** *接收query传参时，传递的参数全部储存在this.$toute.query中 *直接使用传过来的参数名获取值 */ this.id = this.$route.query.id; this.name = this.$route.query.name; console.log(`id:$&#123; this.id &#125;`); // =&gt; 1 console.log(`name:$&#123; this.name &#125;`); // =&gt; &apos;Abbott&apos; &#125; &#125;, created()&#123; this.getData(); &#125;&#125;&lt;/script&gt; 总结一下 params方式传参数据透明，有一定安全性但是在刷新页面后数据会丢失； query方式传参数据不透明，数据跟在url之后，会有一定安全风险但是在刷新页面之后数据不会丢失。]]></content>
      <categories>
        <category>vue组件化开发</category>
      </categories>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历Object的几种方法]]></title>
    <url>%2F2019%2F09%2F22%2F%E9%81%8D%E5%8E%86Object%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js遍历Object的几种方法1. for……in123456789const obj = &#123; id:1, name:&apos;Abbott&apos;, age:18&#125;;for(let key in obj)&#123; console.log(`$&#123;key&#125; --- $&#123;obj[key]&#125;`);&#125;; 输出结果为： id --- 1 name --- Abbott age --- 18 2. Object.keys(obj) &amp; Object.values(obj)参数： obj为将要遍历其可枚举属性并返回数组的对象。 12345678const obj = &#123; id:1, name:&apos;Abbott&apos;, age:18&#125;;console.log(Object.keys(obj));console.log(Object.values(obj)); 输出结果： //obj的key组成的数组 [&quot;id&quot;,&quot;name&quot;,&quot;age&quot;]; //obj的value组成的数组 [&quot;1&quot;,&quot;Abbott&quot;,&quot;18&quot;];3. Object.getOwnPropertyNames(obj)返回一个数组，包括obj中所有属性，包括不可枚举的。 遍历Object.getOwnPropertyNames(obj)的返回值可获得key、value。 12345678const obj = &#123; id:1, name:&apos;zhangsan&apos;, age:18 &#125;;Object.getOwnPropertyNames(obj).forEach(function(key)&#123; console.log(key+&apos;---&apos;+obj[key]);&#125;); 输出结果： id --- 1 name --- Abbott age --- 18]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
        <tag>js遍历Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mock在vue项目中的使用]]></title>
    <url>%2F2019%2F09%2F18%2FThe-method-to-use-of-mock-in-vue%2F</url>
    <content type="text"><![CDATA[作为一个前后端分离的vue开发者，在后台接口和数据都没有的情况下想保证进度过着自测页面功能是一件比较苦恼的事情，当然可以在 *.vue文件的data中自行输入想要的JSON数据，但这样的情况过于麻烦，如果一个复杂的JSON需要改动，工作量和时间消耗是很高的，所以我们需要借用一个能够按自动生成符合你所定义规则的数据的插件或框架。本文将介绍mock.js，一个能够拦截ajax请求并生成随机数据的框架。 一、安装及使用1. mock安装1npm install mockjs 使用时在需要使用mock生成随机数据的文件中使用RequireJS或者import的方式引入mock。 123import Mock from &apos;mockjs&apos;;var Mock = require(&apos;mockjs&apos;); 之后便可以在文件中使用Mock.mock()的方式生成数据。 2. mock的使用使用vue-cli脚手架搭建完项目并引入mockjs依赖之后。在vue项目中直接新建一个名为mock的文件夹（不一定要创建mock文件夹，只要创建一个js文件并引入mockjs即可，放在mock文件夹下只是为了方便管理）。 例如现在新建了一个mock文件夹并在mock目录中新建一个user.js文件： 12345vue-project|+-- mock| +| +-- user.js 在user.js中输入以下demo代码 1234567891011121314151617181920212223242526272829303132import Mock from &apos;mockjs&apos; //引入mockjsconst Random = Mock.Random; //引入Random，Random用来生成随机数据const data = Mock.mock(&#123; //template 模版规则 &apos;items|30&apos;: [&#123; id: &apos;@id&apos;, title: &apos;@sentence(10, 20)&apos;, &apos;status|1&apos;: [&apos;published&apos;, &apos;draft&apos;, &apos;deleted&apos;], author: &apos;name&apos;, display_time: &apos;@datetime&apos;, pageviews: &apos;@integer(300, 5000)&apos; &#125;]&#125;);export default [ //get table list &#123; url: &apos;/table/list&apos;, type: &apos;get&apos;, response: config =&gt; &#123; const items = data.items return &#123; code: 1000, data: &#123; total: items.length, items: items &#125; &#125; &#125; &#125;&#125; 二、Mock.mock(template) 根据数据模版生成模拟数据。 1const data = Mock.mock(template); //其中template处填写的数据规则在下一节 Mock.Random中讲解 三、Mock.Random Mock.Random 是一个工具类，用于生成各种数据。 Mock.Random中的方法在数据模版中被称为占位符，可简写为@占位符（参数），如下例： 1234567var Random = Mock.Random;Random.email();// =&gt; &quot;n.clark@miller.io&quot;Mock.mock(&apos;@email&apos;);// =&gt; &quot;y.lee@lewis.org&quot;Mock.mock( &#123; email: &apos;@email&apos; &#125; );// =&gt; &#123; email: &quot;v.lewis@hall.gov&quot; &#125; 接下来介绍详细的RanDom的用法: 1) Date1. Random.date([format])返回一个随机的日期字符串. format可选属性。 表示生成的日期字符串的格式。默认值为yyy-MM-dd。 Format Description Example yyyy A full numeric representation of a year, 4 digits 1999 or 2003 yy A two digit representation of a year 99 or 03 y A two digit representation of a year 99 or 03 MM Numeric representation of a month, with leading zeros 01 to 12 M Numeric representation of a month, without leading zeros 1 to 12 dd Day of the month, 2 digits with leading zeros 01 to 31 d Day of the month without leading zeros 1 to 31 HH 24-hour format of an hour with leading zeros 00 to 23 H 24-hour format of an hour without leading zeros 0 to 23 hh 12-hour format of an hour without leading zeros 1 to 12 h 12-hour format of an hour with leading zeros 01 to 12 mm Minutes, with leading zeros 00 to 59 m Minutes, without leading zeros 0 to 59 ss Seconds, with leading zeros 00 to 59 s Seconds, without leading zeros 0 to 59 SS Milliseconds, with leading zeros 000 to 999 S Milliseconds, without leading zeros 0 to 999 A Uppercase Ante meridiem and Post meridiem AM or PM a Lowercase Ante meridiem and Post meridiem am or pm T Milliseconds, since 1970-1-1 00:00:00 UTC 759883437303 1234567891011121314Random.extend(&#123; season: function(date) &#123; var seasons = [&apos;春&apos;, &apos;夏&apos;, &apos;秋&apos;, &apos;冬&apos;] return this.pick(seasons) &#125;&#125;);Random.season();// =&gt; &quot;春&quot;Mock.mock(&apos;@SEASON&apos;);// =&gt; &quot;冬&quot;Mock.mock(&#123; season: &apos;@SEANSON&apos;;&#125;);// =&gt; &#123; season: &quot;秋&quot; &#125; 2. Random.time([format])返回一个随机的时间字符串。 format可选属性。 表示生成的时间字符串的格式。默认为HH:mm:ss。 详见Random.date([format])。 3. Random.datetime([format])返回一个随机的日期和时间字符串。 format可选属性。 表示生成的日期和时间字符串的格式。默认为yyyy-MM-dd HH:mm:ss。 详见Random.date([format])。 4. Random.now([unit],[format])返回当前的日期和时间字符串。 unit可选。 表示时间单位，用于对当前日期和时间进行格式化。可选值有：year、month、week、day、hour、minute、second、week，默认不会格式化(日期单位从小至大进行格式化，格式化完unit定义的值后截止)，如下例： 以下是来自官方文档中的例子,也许会不常使用。 123456789101112131415161718192021222324252627Random.now()// =&gt; &quot;2014-04-29 20:08:38 &quot;// =&gt; &quot;2014-04-29 00:00:00 000&quot;Random.now(&apos;day&apos;)// =&gt; &quot;2014-04-29 00:00:00 &quot;Random.now(&apos;year&apos;)// =&gt; &quot;2014-01-01 00:00:00&quot;Random.now(&apos;month&apos;)// =&gt; &quot;2014-04-01 00:00:00&quot;Random.now(&apos;week&apos;)// =&gt; &quot;2014-04-27 00:00:00&quot;Random.now(&apos;day&apos;)// =&gt; &quot;2014-04-29 00:00:00&quot;Random.now(&apos;hour&apos;)// =&gt; &quot;2014-04-29 20:00:00&quot;Random.now(&apos;minute&apos;)// =&gt; &quot;2014-04-29 20:08:00&quot;Random.now(&apos;second&apos;)// =&gt; &quot;2014-04-29 20:08:38&quot; format可选属性。 表示生成的日期和时间字符串的格式。默认为yyyy-MM-dd HH:mm:ss。 详见Random.date([format])。 2) Image1.Random.image([size],[background],[foreground],[format],[text])生成一个随机图片的网络地址。该图片高度会自适应 在github上的mock官方文档中希望使用者在大多数情况下选择更简单的Random.dataImage()。但在我的使用中dataImage会报错而且至今仍未解决掉。。。 Size可选属性。 指定图片的宽高，格式为宽*高。默认从下面的数组中随机选取一个，单位为px： 1234567[ &apos;300x250&apos;, &apos;250x250&apos;, &apos;240x400&apos;, &apos;336x280&apos;, &apos;180x150&apos;, &apos;720x300&apos;, &apos;468x60&apos;, &apos;234x60&apos;, &apos;88x31&apos;, &apos;120x90&apos;, &apos;120x60&apos;, &apos;120x240&apos;, &apos;125x125&apos;, &apos;728x90&apos;, &apos;160x600&apos;, &apos;120x600&apos;, &apos;300x600&apos;] background可选属性。 指定图片的背景色。默认为&#39;#000000&#39;。 foreground可选属性。 指定图片的前景色（文字）。默认为&#39;#FFFFFF&#39;。（mock生成的图片上带有图片尺寸，如’250x250’，会显示在图片上，该属性就是改变图片上文字的字体颜色的） format可选属性。 指定图片的格式。默认为&#39;png&#39;，可选值有&#39;png&#39;、&#39;gif&#39;、&#39;jpg&#39;。 text可选属性。 指定图片上的文字。默认为图片尺寸，如&#39;250x250&#39;，可任意定义一个字符串。 2.Random.dataImage([size],[text])生成一段随机图片的Base64图片编码。 Size可选属性。 指定图片的宽高，格式为宽*高。详见Random.image([size])。 text可选属性。 指定图片上的文字。默认为图片尺寸，如&#39;250x250&#39;，可任意定义一个字符串。 3) Color1. Random.color()生成一个随机颜色，格式为’#RRGGBB’。 12Random.color();// =&gt; &apos;#3538B2&apos; 2. Random.rgb()生成一个随机颜色，格式为’rgb(r,g,b)’。 12Random.rgb();// =&gt; &apos;rgb(242,211,189)&apos; 3. Random.rgba()生成一个随机颜色，格式为’rgb(r,g,b,a)’。 12Random.rgba();// =&gt; &apos;rgb(242,211,189,0.4)&apos; 4) Text1.Random.paragraph([min],[max])生成一段随机的文本。 min,max可选属性。 用来指定生成文本中句子的个数。 min 表示文本中句子的最小个数，默认值为3；max表示文本中句子的最大个数，默认值为7。 12345678Random.paragraph()// =&gt; &quot;Yohbjjz psxwibxd jijiccj kvemj eidnus disnrst rcconm bcjrof tpzhdo ncxc yjws jnmdmty. Dkmiwza ibudbufrnh ndmcpz tomdyh oqoonsn jhoy rueieihtt vsrjpudcm sotfqsfyv mjeat shnqmslfo oirnzu cru qmpt ggvgxwv jbu kjde. Kzegfq kigj.&quot; Random.paragraph(2)// =&gt; &quot;Dlpec hnwvovvnq slfehkf zimy qpxqgy vwrbi mok wozddpol umkek nffjcmk gnqhhvm ztqkvjm kvukg dqubvqn xqbmoda. Vdkceijr fhhyemx hgkruvxuvr kuez wmkfv lusfksuj oewvvf cyw tfpo jswpseupm ypybap kwbofwg uuwn rvoxti ydpeeerf.&quot; Random.paragraph(1, 3)// =&gt; &quot;Qdgfqm puhxle twi lbeqjqfi bcxeeecu pqeqr srsx tjlnew oqtqx zhxhkvq pnjns eblxhzzta hifj csvndh ylechtyu.&quot; 2.Random.cParagraph([min],[max])生成一段随机的中文文本。 min,max详见Random.paragraph([min],[max]) 12345678Random.cparagraph()// =&gt; &quot;给日数时化周作少情者美制论。到先争劳今已美变江以好较正新深。族国般建难出就金感基酸转。任部四那响成族利标铁导术一或已于。省元切世权往着路积会其区素白思断。加把他位间存定国工取除许热规先法方。&quot; Random.cparagraph(2)// =&gt; &quot;去话起时为无子议气根复即传月广。题林里油步不约认山形两标命导社干。&quot; Random.cparagraph(1, 3)// =&gt; &quot;候无部社心性有构员其深例矿取民为。须被亲需报每完认支这明复几下在铁需连。省备可离展五斗器就石正队除解动。&quot; 3. Random.sentence([min],[max])随机生成一个句子，第一个单词首字母大写。 min,max可选属性。 用来指定生成句子中单词的个数，默认为12到18之间的随机数。 min表示句子中单词的最小个数，默认值为12；max表示句子中单词的最大个数，默认值为18。 123456Random.sentence()// =&gt; &quot;Jovasojt qopupwh plciewh dryir zsqsvlkga yeam.&quot;Random.sentence(5)// =&gt; &quot;Fwlymyyw htccsrgdk rgemfpyt cffydvvpc ycgvno.&quot;Random.sentence(3, 5)// =&gt; &quot;Mgl qhrprwkhb etvwfbixm jbqmg.&quot; 4. Random.cSentence([min],[max])随机生成一个中文的句子。 参数值及默认值同 Random.sentence(\[min\],\[max\])。 12345678Random.csentence()// =&gt; &quot;第任人九同段形位第律认得。&quot; Random.csentence(2)// =&gt; &quot;维总。&quot; Random.csentence(1, 3)// =&gt; &quot;厂存。&quot; 5. Random.word([min],[max])随机生成一个单词。 min,max可选属性。 min 表示单词中字符的最小个数，默认值为3；max表示单词中字符的最大个数，默认值为7。 123456Random.word()// =&gt; &quot;fxpocl&quot;Random.word(5)// =&gt; &quot;xfqjb&quot;Random.word(3, 5)// =&gt; &quot;kemh&quot; 6. Random.cWord([pool],[min],[max])随机生成一个中文单词。 pool可选属性 汉字字符串。表示汉字字符池，将从中选择一个汉字字符返回。 min,max参数值及默认值同 Random.word(\[min\],\[max\])。 123456789101112Random.cword()// =&gt; &quot;干&quot;Random.cword(&apos;零一二三四五六七八九十&apos;)// =&gt; &quot;六&quot;Random.cword(3)// =&gt; &quot;别金提&quot;Random.cword(&apos;零一二三四五六七八九十&apos;, 3)// =&gt; &quot;&quot;七七七&quot;&quot;Random.cword(5, 7)// =&gt; &quot;设过证全争听&quot;Random.cword(&apos;零一二三四五六七八九十&apos;, 5, 7)// =&gt; &quot;九七七零四&quot; 7. Random.title([min],[max])min,max可选属性。 随机生成一个标题，其中每个单词首字母大写。 min 表示标题中单词的最小个数，默认值为3；max表示标题中单词的最大个数，默认值为7。 123456Random.title()// =&gt; &quot;Rduqzr Muwlmmlg Siekwvo Ktn Nkl Orn&quot;Random.title(5)// =&gt; &quot;Ahknzf Btpehy Xmpc Gonehbnsm Mecfec&quot;Random.title(3, 5)// =&gt; &quot;Hvjexiondr Pyickubll Owlorjvzys Xfnfwbfk&quot; 8. Random.cTitle([min],[max])min,max参数值及默认值同 Random.title(\[min\],\[max\])。 123456Random.ctitle()// =&gt; &quot;证构动必作&quot;Random.ctitle(5)// =&gt; &quot;应青次影育&quot;Random.ctitle(3, 5)// =&gt; &quot;出料阶相&quot; 5) Name1. Random.first()随机生成一个常见的英文名。 12Random.first()// =&gt; &quot;Nancy&quot; 2. Random.last()随机生成一个常见的英文姓。 12Random.last()// =&gt; &quot;Martinez&quot; 3. Random.name([middle])随机生成一个常见的英文姓名。 middle可选属性。 布尔值。指示是否生成中间名。 1234Random.name()// =&gt; &quot;Larry Wilson&quot;Random.name(true)// =&gt; &quot;Helen Carol Martinez&quot; 4. Random.cfirst()随机生成一个常见的中文名。 12Random.cfirst()// =&gt; &quot;曹&quot; 5. Random.clast()随机生成一个常见的中文姓。 12Random.clast()// =&gt; &quot;艳&quot; 6. Random.cname()随机生成一个常见的中文姓名。 12Random.cname()// =&gt; &quot;袁军&quot; 6) Web1. Random.url([protocol],[host])随机生成一个 URL。 protocol指定 URL 协议。例如 http。 host指定 URL 域名和端口号。例如 nuysoft.com。 123456Random.url()// =&gt; &quot;mid://axmg.bg/bhyq&quot;Random.url(&apos;http&apos;)// =&gt; &quot;http://splap.yu/qxzkyoubp&quot;Random.url(&apos;http&apos;, &apos;nuysoft.com&apos;)// =&gt; &quot;http://nuysoft.com/ewacecjhe&quot; 2. Random.email([domain])随机生成一个邮件地址。 domain可选属性。 指定邮件地址的域名。例如 nuysoft.com。 1234Random.email()// =&gt; &quot;x.davis@jackson.edu&quot;Random.email(&apos;nuysoft.com&apos;)// =&gt; &quot;h.pqpneix@nuysoft.com&quot; 3. Random.ip()随机生成一个 IP 地址。 12Random.ip()// =&gt; &quot;34.206.109.169&quot; 7) Address1. Random.region()随机生成一个中国的大区。 12Random.region();// =&gt; &quot;华北&quot; 2. Random.province()随机生成一个中国的省（或直辖市、自治区、特别行政区） 12Random.province();// =&gt; &quot;黑龙江省&quot; 3. Random.city([prefix])随机生成一个中国的市。 prefix可选属性。 布尔值，表示是否生成所属的省。 1234Random.city()// =&gt; &quot;唐山市&quot;Random.city(true)// =&gt; &quot;山东省 济南市&quot; 4. Random.county([prefix])随机生成一个中国的市。 prefix可选属性。 布尔值，表示是否生成所属的省、市。 1234Random.city()// =&gt; &quot;唐山市&quot;Random.city(true)// =&gt; &quot;甘肃省 白银市 会宁县&quot; 5. Random.zip()随机生成一个邮政编码（六位数字）。 12Random.zip();// =&gt; &quot;100000&quot; 8) 扩展方法Mock.Random中的方法与@占位符`相对应，在需要时还可以为Mock.Random扩展方法,与占位符使用规则相同。例如： 1234567891011121314Random.extend(&#123; season: function(date) &#123; var seasons = [&apos;春&apos;, &apos;夏&apos;, &apos;秋&apos;, &apos;冬&apos;] return this.pick(seasons) &#125;&#125;);Random.season();// =&gt; &quot;春&quot;Mock.mock(&apos;@SEASON&apos;);// =&gt; &quot;冬&quot;Mock.mock(&#123; season: &apos;@SEANSON&apos;;&#125;);// =&gt; &#123; season: &quot;秋&quot; &#125; 以上所罗列的不是全部的规则，是我个人平时常用的一些。]]></content>
      <categories>
        <category>vue组件化开发</category>
      </categories>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>前端假数据自测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elementUI各个组件在具体使用中的问题]]></title>
    <url>%2F2019%2F09%2F10%2FelementUI%E5%90%84%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%9C%A8%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、elementUI 时间控件表单验证方法 elementUI中的日期时间控件是挺不错的，日期选择的逻辑也还比较符合人们的正常习惯，但是该控件是一个标签生成两个input框的，在表单验证中无法使用required来验证是否非空。本篇文章是我采取的解决方法，也奏效了。可以作为参考。 👇这是elementUI时间控件的HTML结构， 这是在data return中定义的验证规则，validator属性调用自定义验证规则，此处为calidatorTime，该方法会自带三个参数 rule，value，callback；其中callback是方法，callback（）表示验证通过。callback（new Error（“此填写报错信息”））表示没有通过验证并提示错误信息. 自定义的validator验证规则方法需在data（）{}中以变量形式定义， 尝试过在rules:[]规则中把validator作为其中一个属性，下面是一个网上的小例子，意在说明格式： 12345678910111213mobile:[&#123; required: true, message: '请输入手机号码', trigger: 'blur' &#125;, &#123;validator:function(rule,value,callback)&#123; if(/^1[34578]\d&#123;9&#125;$/.test(value) == false)&#123; callback(new Error("请输入正确的手机号")); &#125;else&#123; callback(); &#125; &#125;, trigger: 'blur'&#125; ] 也许是因为elementUI中这个日期时间控件是单标签渲染出两个input框的缘故（口误），这种写法不奏效，还是只能采用我最开始的那种写法。 切记，如果有表单验证的页面，在类似提交或者保存功能的按钮的点击方法中嵌套一层以上代码，会在触发点击事件时进行表单验证，如果通过验证才能继续运行代码。]]></content>
      <categories>
        <category>vue组件化开发</category>
      </categories>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>elementUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个axios如何进行同步请求]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%A4%9A%E4%B8%AAaxios%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[多个axios如何进行同步请求 在我使用vue+axios进行开发的过程中，会碰到有两个异步请求，且其中一个请求需要另一个请求的返回值，那此时将两个异步的axios请求同步执行才是最好的方式。本文中整理了两种axios同步请求的方式。 一、 使用axios官方的axios.all()方法即可同步执行内部的多个异步axios操作。 axiosReq1(params){ //将axios对象封装 this.axios.post(‘/login’,…{params}); }; axiosReq2(params){ this.axios.post(‘/register’,…{params}); }; ··· ··· this.axios.all([axiosReq1(params),axiosReq2(params)…axiosReqX(params)]) .then(function(res1,res2…resX){ console.log(res1,res1); console.log(res2,res2); ... console.log(resX,resX); })二、 因为axios是vue基于es6的promise语法对ajax进行的封装，每个axios.get/post()就是一个promise对象，即axios.()内部可使用promise语法的return对回调函数进行执行。（具体es6及promise对象请移步至其他博客进行了解😉） this.axios.get(&apos;/login&apos;) .then((res) =&gt; { if (res.status) { ... console.log(res); }; return this.axios.get(&apos;/getDatas&apos;)； }) .then((res)=&gt;{ if (res.status) { console.log(res); } })]]></content>
      <categories>
        <category>vue组件化开发</category>
      </categories>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中变量的深浅拷贝]]></title>
    <url>%2F2019%2F09%2F09%2Fcopy%2F</url>
    <content type="text"><![CDATA[js中 对象和数组的深浅拷贝 一般我们在将值从一个基本数据类型的变量赋值给另一个基本数据类型的变量时，简单的赋值即可实现，如： var a = 1; var b = a; // b:1 简单赋值 b = 2； //a:1,b:2 即使改变b的值，也不会影响a 这个简单的例子证明了基本数据类型的变量只需要简单赋值即可。但是在给对象和数组赋值的时候这种方法就不可行了，涉及到了深浅拷贝的问题，下面会介绍到。 一、数据类型js中有基本数据类型和引用（复杂）数据类型两种。 &nbsp;&nbsp;&nbsp;&nbsp; 其中： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1） 基本数据类型: Number（数值）、String（字符串）、Boolean（布尔）、null、undefined、symbol（es6中出现的新类型，用于当作唯一标识，此处不过多赘述）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2） 引用数据类型: Object（对象）。 基本数据类型的赋值正如在文章开头说到的那样，基本数据类型用简单的 = 就能完成赋值。是因为简单数据类型在定义时，会在内存中重新开辟空间来存放新的变量，在内存之中存在着新旧两个变量的空间，互不影响。 引用数据类型的赋值 12345var arr1 = [1,2,3]; //arr1为数组var arr2 = arr1; //将arr1的值赋给arr2，arr2:[1,2,3]arr2.push(4); //改变arr2的值, //arr1:[1,2,3,4],arr1的值也被改变 在此处arr1与arr2指向的是内存中的同一地址，知识赋值了地址。 因此，引用数据类型之间的赋值不能使用简单的复制，此处就涉及到了浅拷贝和深拷贝。 二、深浅拷贝在对象/数组中，浅拷贝只是复制了某个对象的指针，而不是对象本身。深拷贝则是创建一个和原对象一摸一样的对象，两个对象之间互不影响。 浅拷贝 &nbsp;&nbsp;&nbsp;&nbsp; 浅拷贝只是对基本数据类型的拷贝。 123var a = 1;var b = a; //b:1b = 2; //a:1,b:2 &nbsp;&nbsp;&nbsp;&nbsp; 对于引用数据类型来说这样的简单赋值不可行，但如果 数组/对象 的 项/属性 也是基本数据类型，那么可以使用遍历的方式来进行赋值而两个数组/对象之间互不影响。 12345678910var arr1 = [1,2,3];var arr2 = [];for (let i = 0;i&lt;arr1.length;i++)&#123; arr2[i] = arr1[i]; //arr1的每一项都是number基本数据类型，可以使用这样的方式进行赋值.&#125; //arr2:[1,2,3]arr2[0] = 4; //arr1:[1,2,3] //arr2:[4,2,3] //改变了arr2，arr1的值并没有改变 深拷贝&nbsp;&nbsp;&nbsp;&nbsp; 如果是下面这种情况，简单的遍历赋值也无法实现深拷贝。 12345678910var arr1 = [1,2,[3,4]];var arr2 = [];for (let i = 0;i&lt;arr1.length;i++)&#123; arr2[i] = arr1[i]; &#125; //arr2:[1,2,[3,4]]arr2[2][1] = 5; //arr1:[1,2,[3,5]] //arr2:[1,2,[3,5]] //改变了arr2中引用数据类型项的值，arr1的值跟着改变了。 1234567891011121314var obj1 = &#123; a:1, b:2, c:[1,2,3]&#125;;var obj2 = &#123;&#125;;Object.keys(obj1).forEach(function(key)&#123; obj2[key] = obj1[key];&#125;); //obj2:&#123;a:1,b:2,c:[1,2,3]&#125;obj2.c[0] = 4; //obj2:&#123;a:1,b:2,c:[4,2,3]&#125; //obj1:&#123;a:1,b:2,c:[4,2,3]&#125; //改变了obj2中引用数据类型项的值，obj1的值跟着改变了。 &nbsp;&nbsp;&nbsp;&nbsp;所以此时介绍两个起到深拷贝作用的方法：concat()、Object.assign() concat（）、Object.assign()方对用途不止如此，此处讨论深拷贝的方法，不对其他功能过多阐述 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)concat() concat()方法用来对数组进行深拷贝操作 12345var arr1 = [1,2,3];var arr2 = [].concat(arr1); //arr2:[1,2,3]arr2[0] = 0; //arr2 = [0,2,3] //arr1 = [1,2,3] arr1并未受到影响 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)$.extend() Object.assign()方法用来对对象进行深拷贝操作 123456789var obj1 = &#123; a:1, b:2, c:[1,2,3]&#125;;var obj2 = Object.assign(&#123;&#125;,obj1); //obj2:&#123;a:1,b:2,c:[1,2,3]&#125;obj2.c[0] = 0; //obj2:&#123;a:1,b:2,c:[0,2,3]&#125; //obj1:&#123;a:1,b:2,c:[1,2,3]&#125; obj1并未受到影响]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js对数组的一些操作方法]]></title>
    <url>%2F2019%2F09%2F05%2FJs%20Array%20and%20String%2F</url>
    <content type="text"><![CDATA[本文主要介绍js中对数组和字符串的基本操作 一. 数组操作 概念 数组操作分为两类: 会改变原数组的方法: .push(), .pop(), .shift(), .unshift(), .splice(), .reverse(), .sort(); 不会改变原数组的方法: .concat(), .slice(), .join()。 1）改变原数组的操作push()push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。 例子1234567var arr = [1,2,3,4,5,6];arr.push([7,8]); //arr:[1,2,3,4,5,6,[7,8]] //如果插入的为数组，则插入的这个数组成为arr的最后一项var count = arr.push(9,10); //arr:[1,2,3,4,5,6,[7,8],9,10] //count:9 == 返回值为改变后数组的长度 pop()pop()方法用于删除数组的最后一个元素，并返回被删除的元素。 例子1234var arr = [1,2,3,4,5,6];var item = arr.pop(); //arr:[1,2,3,4,5] //item:6 == 返回值为被删除的元素 shift()shif()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值. 例子1234var arr = [1,2,3,4,5,6];var item = arr.shift(); //arr:[2,3,4,5,6] //item:1 == 返回值为被删除的元素 unshift()unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度. 例子1234567var arr = [1,2,3,4,5,6];var count = arr.unshift(1,2); //arr:[1,2,1,2,3,4,5,6] //count:8 == 返回数组的长度var count = arr.unshift([1,2]); //arr:[[1,2],1,2,1,2,3,4,5,6] //count:9 splice()splice() 方法向数组中添加项目(或 向数组中添加项目)，然后返回被删除的项目，返回值为数组。 一句话概括一下：此方法不是单纯的添加或者删除数组中的项，更像是更改数组。从索引为index的项开始（包括index项）往后面找个数length的项，将他们替换为item1…itemX 1语法：arrayObject.splice(index,length,item1,.....,itemX) 参数 描述 index 必填。规定添加（删除）的位置。即从索引为index的项为起点。如果为负数则从倒数项开始。 length 必填。规定删除的项的个数，如果为0则不删除。 item1…itemX 选填。规定添加的项。如果有item1…itemX，则不论是否删除，item1…itemX都会添加到数组。 例子1234567var arr = [1,2,3,4,5,6];var items = arr.splice(5,1); //arr:[1,2,3,4,5] 此用法表现为删除操作 //items:[6] 返回被删除的项var items = arr.splice(4,1,7,8,9); //arr:[1,2,3,4,7,8,9] 此用法表现为更改操作。从第index为4的项开始的1项删除，并插入 7，8，9 //count:[5] 返回被删除的项 reverse()reverse() 方法用于颠倒数组中元素的顺序，无返回值。 例子123var arr = [a,b,c,d];arr.reverse(); //arr:[d,c,b,a] sort()sort() 方法用于对数组的元素进行排序，无返回值。 例子123456789var arr = [1,5,3,2,4];arr.sort(); //arr:[1,2,3,4,5] 完成排序//但是注意，该方法仅用于对数组项为单纯数字的数组进行排序，如果数组的项为字符串，结果可能不为预期var strArr = ['1','12','2','5','300'];strArr.sort(); //strArr:['1','12','2','300','5'] 2）不会改变原数组的操作concat()concat() 方法用于两个或多个数组的拼接,返回值为拼接后的新数组。 1语法： arr1.concat(arr2,arr3...arrX); 其中arr2...arrX可以是具体的项 例子12345var arr1 = [1,2,3];var arr2 = arr1.concat(4,5); //arr2 = [1,2,3,4,5]var arr3 = arr1.concat([4,5]); //arr3 = [1,2,3,4,5] //arr1 = [1,2,3] -- 不改变原数组 &nbsp;&nbsp; 以上两个操作拼接的为不同对象，但结果是一样的，由此看出concat()方法返回值有且只有一个数组。如果传入参数为数组，会将数组的每个项拆分再进行拼接操作。 *tips:因concat()不会改变任何数组就能复制出一个与原数组一摸一样的数组，所以多用来对数组进行深拷贝操作 var arr1 = [1,2,3]; var arr2 = [].concat(arr1); //将arr1的值与空数组拼接，意在将arr1的值复制一份。slice()slice() 方法用于返回一个数组的选定元素,并存放在一个新数组中。 1语法： arr.slice(start,end); 参数 描述 start 必填。用来指定选取的起点，从索引为start的项开始。 end 选填。用来指定选取的终点，选取到索引为end的项的前一项，不包括索引为end的项本身。如不填，则选取到数组的最后一位。 例子123456var arr1 = [1,2,3,4,5,6];var arr2 = arr1.slice(1);//arr2:[2,3,4,5,6]var arr3 = arr1.slice(2,4);//arr3 = [3,4] 2. 字符串操作 概念 数组操作分为两类: 会改变原数组的方法: .push(), .pop(), .shift(), .unshift(), .splice(), .reverse(), .sort(); 不会改变原数组的方法: .concat(), .slice()。]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js数组</tag>
        <tag>js基础</tag>
      </tags>
  </entry>
</search>
