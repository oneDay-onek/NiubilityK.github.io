<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mock在vue项目中的使用]]></title>
    <url>%2F2019%2F09%2F18%2FThe-method-to-use-of-mock-in-vue%2F</url>
    <content type="text"><![CDATA[作为一个前后端分离的vue开发者，在后台接口和数据都没有的情况下想保证进度过着自测页面功能是一件比较苦恼的事情，当然可以在 *.vue文件的data中自行输入想要的JSON数据，但这样的情况过于麻烦，如果一个复杂的JSON需要改动，工作量和时间消耗是很高的，所以我们需要借用一个能够按自动生成符合你所定义规则的数据的插件或框架。本文将介绍mock.js，一个能够拦截ajax请求并生成随机数据的框架。 一、安装及使用1. mock安装1npm install mockjs 使用时在需要使用mock生成随机数据的文件中使用RequireJS或者import的方式引入mock。 123import Mock from &apos;mockjs&apos;;var Mock = require(&apos;mockjs&apos;); 之后便可以在文件中使用Mock.mock()的方式生成数据。 2. mock的使用使用vue-cli脚手架搭建完项目并引入mockjs依赖之后。在vue项目中直接新建一个名为mock的文件夹（不一定要创建mock文件夹，只要创建一个js文件并引入mockjs即可，放在mock文件夹下只是为了方便管理）。 例如现在新建了一个mock文件夹并在mock目录中新建一个user.js文件： 12345vue-project|+-- mock| +| +-- user.js 在user.js中输入以下demo代码 1234567891011121314151617181920212223242526272829303132import Mock from &apos;mockjs&apos; //引入mockjsconst Random = Mock.Random; //引入Random，Random用来生成随机数据const data = Mock.mock(&#123; //template 模版规则 &apos;items|30&apos;: [&#123; id: &apos;@id&apos;, title: &apos;@sentence(10, 20)&apos;, &apos;status|1&apos;: [&apos;published&apos;, &apos;draft&apos;, &apos;deleted&apos;], author: &apos;name&apos;, display_time: &apos;@datetime&apos;, pageviews: &apos;@integer(300, 5000)&apos; &#125;]&#125;);export default [ //get table list &#123; url: &apos;/table/list&apos;, type: &apos;get&apos;, response: config =&gt; &#123; const items = data.items return &#123; code: 1000, data: &#123; total: items.length, items: items &#125; &#125; &#125; &#125;&#125; 二、Mock.mock(template) 根据数据模版生成模拟数据。 1const data = Mock.mock(template); //其中template处填写的数据规则在下一节 Mock.Random中讲解 三、Mock.Random Mock.Random 是一个工具类，用于生成各种数据。 Mock.Random中的方法在数据模版中被称为占位符，可简写为@占位符（参数），如下例： 1234567var Random = Mock.Random;Random.email();// =&gt; &quot;n.clark@miller.io&quot;Mock.mock(&apos;@email&apos;);// =&gt; &quot;y.lee@lewis.org&quot;Mock.mock( &#123; email: &apos;@email&apos; &#125; );// =&gt; &#123; email: &quot;v.lewis@hall.gov&quot; &#125; 接下来介绍详细的RanDom的用法: 1) Date1. Random.date([format])返回一个随机的日期字符串. format可选属性。 表示生成的日期字符串的格式。默认值为yyy-MM-dd。 Format Description Example yyyy A full numeric representation of a year, 4 digits 1999 or 2003 yy A two digit representation of a year 99 or 03 y A two digit representation of a year 99 or 03 MM Numeric representation of a month, with leading zeros 01 to 12 M Numeric representation of a month, without leading zeros 1 to 12 dd Day of the month, 2 digits with leading zeros 01 to 31 d Day of the month without leading zeros 1 to 31 HH 24-hour format of an hour with leading zeros 00 to 23 H 24-hour format of an hour without leading zeros 0 to 23 hh 12-hour format of an hour without leading zeros 1 to 12 h 12-hour format of an hour with leading zeros 01 to 12 mm Minutes, with leading zeros 00 to 59 m Minutes, without leading zeros 0 to 59 ss Seconds, with leading zeros 00 to 59 s Seconds, without leading zeros 0 to 59 SS Milliseconds, with leading zeros 000 to 999 S Milliseconds, without leading zeros 0 to 999 A Uppercase Ante meridiem and Post meridiem AM or PM a Lowercase Ante meridiem and Post meridiem am or pm T Milliseconds, since 1970-1-1 00:00:00 UTC 759883437303 1234567891011121314Random.extend(&#123; season: function(date) &#123; var seasons = [&apos;春&apos;, &apos;夏&apos;, &apos;秋&apos;, &apos;冬&apos;] return this.pick(seasons) &#125;&#125;);Random.season();// =&gt; &quot;春&quot;Mock.mock(&apos;@SEASON&apos;);// =&gt; &quot;冬&quot;Mock.mock(&#123; season: &apos;@SEANSON&apos;;&#125;);// =&gt; &#123; season: &quot;秋&quot; &#125; 2. Random.time([format])返回一个随机的时间字符串。 format可选属性。 表示生成的时间字符串的格式。默认为HH:mm:ss。 详见Random.date([format])。 3. Random.datetime([format])返回一个随机的日期和时间字符串。 format可选属性。 表示生成的日期和时间字符串的格式。默认为yyyy-MM-dd HH:mm:ss。 详见Random.date([format])。 4. Random.now([unit],[format])返回当前的日期和时间字符串。 unit可选。 表示时间单位，用于对当前日期和时间进行格式化。可选值有：year、month、week、day、hour、minute、second、week，默认不会格式化(日期单位从小至大进行格式化，格式化完unit定义的值后截止)，如下例： 以下是来自官方文档中的例子,也许会不常使用。 123456789101112131415161718192021222324252627Random.now()// =&gt; &quot;2014-04-29 20:08:38 &quot;// =&gt; &quot;2014-04-29 00:00:00 000&quot;Random.now(&apos;day&apos;)// =&gt; &quot;2014-04-29 00:00:00 &quot;Random.now(&apos;year&apos;)// =&gt; &quot;2014-01-01 00:00:00&quot;Random.now(&apos;month&apos;)// =&gt; &quot;2014-04-01 00:00:00&quot;Random.now(&apos;week&apos;)// =&gt; &quot;2014-04-27 00:00:00&quot;Random.now(&apos;day&apos;)// =&gt; &quot;2014-04-29 00:00:00&quot;Random.now(&apos;hour&apos;)// =&gt; &quot;2014-04-29 20:00:00&quot;Random.now(&apos;minute&apos;)// =&gt; &quot;2014-04-29 20:08:00&quot;Random.now(&apos;second&apos;)// =&gt; &quot;2014-04-29 20:08:38&quot; format可选属性。 表示生成的日期和时间字符串的格式。默认为yyyy-MM-dd HH:mm:ss。 详见Random.date([format])。 2) Image1. Random.image([size],[background],[foreground],[format],[text])生成一个随机图片的网络地址。该图片高度会自适应 在github上的mock官方文档中希望使用者在大多数情况下选择更简单的Random.dataImage()。但在我的使用中dataImage会报错而且至今仍未解决掉。。。 Size可选属性。 指定图片的宽高，格式为宽*高。默认从下面的数组中随机选取一个，单位为px： 1234567[ &apos;300x250&apos;, &apos;250x250&apos;, &apos;240x400&apos;, &apos;336x280&apos;, &apos;180x150&apos;, &apos;720x300&apos;, &apos;468x60&apos;, &apos;234x60&apos;, &apos;88x31&apos;, &apos;120x90&apos;, &apos;120x60&apos;, &apos;120x240&apos;, &apos;125x125&apos;, &apos;728x90&apos;, &apos;160x600&apos;, &apos;120x600&apos;, &apos;300x600&apos;] background可选属性。 指定图片的背景色。默认为&#39;#000000&#39;。 foreground可选属性。 指定图片的前景色（文字）。默认为&#39;#FFFFFF&#39;。（mock生成的图片上带有图片尺寸，如’250x250’，会显示在图片上，该属性就是改变图片上文字的字体颜色的） format可选属性。 指定图片的格式。默认为&#39;png&#39;，可选值有&#39;png&#39;、&#39;gif&#39;、&#39;jpg&#39;。 text可选属性。 指定图片上的文字。默认为图片尺寸，如&#39;250x250&#39;，可任意定义一个字符串。 1. Random.dataImage([size],[text])生成一段随机图片的Base64图片编码。 Size可选属性。 指定图片的宽高，格式为宽*高。详见Random.image([size])。 text可选属性。 指定图片上的文字。默认为图片尺寸，如&#39;250x250&#39;，可任意定义一个字符串。 -1) 扩展方法Mock.Random中的方法与@占位符`相对应，在需要时还可以为Mock.Random扩展方法,与占位符使用规则相同。例如： 1234567891011121314Random.extend(&#123; season: function(date) &#123; var seasons = [&apos;春&apos;, &apos;夏&apos;, &apos;秋&apos;, &apos;冬&apos;] return this.pick(seasons) &#125;&#125;);Random.season();// =&gt; &quot;春&quot;Mock.mock(&apos;@SEASON&apos;);// =&gt; &quot;冬&quot;Mock.mock(&#123; season: &apos;@SEANSON&apos;;&#125;);// =&gt; &#123; season: &quot;秋&quot; &#125;]]></content>
      <categories>
        <category>vue组件化开发</category>
      </categories>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>前端假数据自测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试文章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[elementUI各个组件在具体使用中的问题]]></title>
    <url>%2F2019%2F09%2F10%2FelementUI%E5%90%84%E4%B8%AA%E7%BB%84%E4%BB%B6%E5%9C%A8%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、elementUI 时间控件表单验证方法 elementUI中的日期时间控件是挺不错的，日期选择的逻辑也还比较符合人们的正常习惯，但是该控件是一个标签生成两个input框的，在表单验证中无法使用required来验证是否非空。本篇文章是我采取的解决方法，也奏效了。可以作为参考。 👇这是elementUI时间控件的HTML结构， 这是在data return中定义的验证规则，validator属性调用自定义验证规则，此处为calidatorTime，该方法会自带三个参数 rule，value，callback；其中callback是方法，callback（）表示验证通过。callback（new Error（“此填写报错信息”））表示没有通过验证并提示错误信息. 自定义的validator验证规则方法需在data（）{}中以变量形式定义， 尝试过在rules:[]规则中把validator作为其中一个属性，下面是一个网上的小例子，意在说明格式： 12345678910111213mobile:[&#123; required: true, message: '请输入手机号码', trigger: 'blur' &#125;, &#123;validator:function(rule,value,callback)&#123; if(/^1[34578]\d&#123;9&#125;$/.test(value) == false)&#123; callback(new Error("请输入正确的手机号")); &#125;else&#123; callback(); &#125; &#125;, trigger: 'blur'&#125; ] 也许是因为elementUI中这个日期时间控件是单标签渲染出两个input框的缘故（口误），这种写法不奏效，还是只能采用我最开始的那种写法。 切记，如果有表单验证的页面，在类似提交或者保存功能的按钮的点击方法中嵌套一层以上代码，会在触发点击事件时进行表单验证，如果通过验证才能继续运行代码。]]></content>
      <categories>
        <category>vue组件化开发</category>
      </categories>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>elementUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个axios如何进行同步请求]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%A4%9A%E4%B8%AAaxios%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[多个axios如何进行同步请求 在我使用vue+axios进行开发的过程中，会碰到有两个异步请求，且其中一个请求需要另一个请求的返回值，那此时将两个异步的axios请求同步执行才是最好的方式。本文中整理了两种axios同步请求的方式。 一、 使用axios官方的axios.all()方法即可同步执行内部的多个异步axios操作。 axiosReq1(params){ //将axios对象封装 this.axios.post(‘/login’,…{params}); }; axiosReq2(params){ this.axios.post(‘/register’,…{params}); }; ··· ··· this.axios.all([axiosReq1(params),axiosReq2(params)…axiosReqX(params)]) .then(function(res1,res2…resX){ console.log(res1,res1); console.log(res2,res2); ... console.log(resX,resX); })二、 因为axios是vue基于es6的promise语法对ajax进行的封装，每个axios.get/post()就是一个promise对象，即axios.()内部可使用promise语法的return对回调函数进行执行。（具体es6及promise对象请移步至其他博客进行了解😉） this.axios.get(&apos;/login&apos;) .then((res) =&gt; { if (res.status) { ... console.log(res); }; return this.axios.get(&apos;/getDatas&apos;)； }) .then((res)=&gt;{ if (res.status) { console.log(res); } })]]></content>
      <categories>
        <category>vue组件化开发</category>
      </categories>
      <tags>
        <tag>vue组件化开发</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中变量的深浅拷贝]]></title>
    <url>%2F2019%2F09%2F09%2Fcopy%2F</url>
    <content type="text"><![CDATA[js中 对象和数组的深浅拷贝 一般我们在将值从一个基本数据类型的变量赋值给另一个基本数据类型的变量时，简单的赋值即可实现，如： var a = 1; var b = a; // b:1 简单赋值 b = 2； //a:1,b:2 即使改变b的值，也不会影响a 这个简单的例子证明了基本数据类型的变量只需要简单赋值即可。但是在给对象和数组赋值的时候这种方法就不可行了，涉及到了深浅拷贝的问题，下面会介绍到。 一、数据类型js中有基本数据类型和引用（复杂）数据类型两种。 &nbsp;&nbsp;&nbsp;&nbsp; 其中： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1） 基本数据类型: Number（数值）、String（字符串）、Boolean（布尔）、null、undefined、symbol（es6中出现的新类型，用于当作唯一标识，此处不过多赘述）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2） 引用数据类型: Object（对象）。 基本数据类型的赋值正如在文章开头说到的那样，基本数据类型用简单的 = 就能完成赋值。是因为简单数据类型在定义时，会在内存中重新开辟空间来存放新的变量，在内存之中存在着新旧两个变量的空间，互不影响。 引用数据类型的赋值 12345var arr1 = [1,2,3]; //arr1为数组var arr2 = arr1; //将arr1的值赋给arr2，arr2:[1,2,3]arr2.push(4); //改变arr2的值, //arr1:[1,2,3,4],arr1的值也被改变 在此处arr1与arr2指向的是内存中的同一地址，知识赋值了地址。 因此，引用数据类型之间的赋值不能使用简单的复制，此处就涉及到了浅拷贝和深拷贝。 二、深浅拷贝在对象/数组中，浅拷贝只是复制了某个对象的指针，而不是对象本身。深拷贝则是创建一个和原对象一摸一样的对象，两个对象之间互不影响。 浅拷贝 &nbsp;&nbsp;&nbsp;&nbsp; 浅拷贝只是对基本数据类型的拷贝。 123var a = 1;var b = a; //b:1b = 2; //a:1,b:2 &nbsp;&nbsp;&nbsp;&nbsp; 对于引用数据类型来说这样的简单赋值不可行，但如果 数组/对象 的 项/属性 也是基本数据类型，那么可以使用遍历的方式来进行赋值而两个数组/对象之间互不影响。 12345678910var arr1 = [1,2,3];var arr2 = [];for (let i = 0;i&lt;arr1.length;i++)&#123; arr2[i] = arr1[i]; //arr1的每一项都是number基本数据类型，可以使用这样的方式进行赋值.&#125; //arr2:[1,2,3]arr2[0] = 4; //arr1:[1,2,3] //arr2:[4,2,3] //改变了arr2，arr1的值并没有改变 深拷贝&nbsp;&nbsp;&nbsp;&nbsp; 如果是下面这种情况，简单的遍历赋值也无法实现深拷贝。 12345678910var arr1 = [1,2,[3,4]];var arr2 = [];for (let i = 0;i&lt;arr1.length;i++)&#123; arr2[i] = arr1[i]; &#125; //arr2:[1,2,[3,4]]arr2[2][1] = 5; //arr1:[1,2,[3,5]] //arr2:[1,2,[3,5]] //改变了arr2中引用数据类型项的值，arr1的值跟着改变了。 1234567891011121314var obj1 = &#123; a:1, b:2, c:[1,2,3]&#125;;var obj2 = &#123;&#125;;Object.keys(obj1).forEach(function(key)&#123; obj2[key] = obj1[key];&#125;); //obj2:&#123;a:1,b:2,c:[1,2,3]&#125;obj2.c[0] = 4; //obj2:&#123;a:1,b:2,c:[4,2,3]&#125; //obj1:&#123;a:1,b:2,c:[4,2,3]&#125; //改变了obj2中引用数据类型项的值，obj1的值跟着改变了。 &nbsp;&nbsp;&nbsp;&nbsp; 所以此时介绍两个起到深拷贝作用的方法：concat()、$.extend() concat（）、$.extend()方对用途不止如此，此处讨论深拷贝的方法，不对其他功能过多阐述 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)concat() concat()方法用来对数组进行深拷贝操作 12345var arr1 = [1,2,3];var arr2 = [].concat(arr1); //arr2:[1,2,3]arr2[0] = 0; //arr2 = [0,2,3] //arr1 = [1,2,3] arr1并未受到影响 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)$.extend() $.extend()方法用来对对象进行深拷贝操作 123456789var obj1 = &#123; a:1, b:2, c:[1,2,3]&#125;;var obj2 = $.extend(&#123;&#125;,obj1); //obj2:&#123;a:1,b:2,c:[1,2,3]&#125;obj2.c[0] = 0; //obj2:&#123;a:1,b:2,c:[0,2,3]&#125; //obj1:&#123;a:1,b:2,c:[1,2,3]&#125; obj1并未受到影响]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js对数组的一些操作方法]]></title>
    <url>%2F2019%2F09%2F05%2FJs%20Array%20and%20String%2F</url>
    <content type="text"><![CDATA[本文主要介绍js中对数组和字符串的基本操作 一. 数组操作 概念 数组操作分为两类: 会改变原数组的方法: .push(), .pop(), .shift(), .unshift(), .splice(), .reverse(), .sort(); 不会改变原数组的方法: .concat(), .slice()。 1）改变原数组的操作push()push()方法可向数组的末尾添加一个或多个元素，并返回新的长度。 例子1234567var arr = [1,2,3,4,5,6];arr.push([7,8]); //arr:[1,2,3,4,5,6,[7,8]] //如果插入的为数组，则插入的这个数组成为arr的最后一项var count = arr.push(9,10); //arr:[1,2,3,4,5,6,[7,8],9,10] //count:9 == 返回值为改变后数组的长度 pop()pop()方法用于删除数组的最后一个元素，并返回被删除的元素。 例子1234var arr = [1,2,3,4,5,6];var item = arr.pop(); //arr:[1,2,3,4,5] //item:6 == 返回值为被删除的元素 shift()shif()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值. 例子1234var arr = [1,2,3,4,5,6];var item = arr.shift(); //arr:[2,3,4,5,6] //item:1 == 返回值为被删除的元素 unshift()unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度. 例子1234567var arr = [1,2,3,4,5,6];var count = arr.unshift(1,2); //arr:[1,2,1,2,3,4,5,6] //count:8 == 返回数组的长度var count = arr.unshift([1,2]); //arr:[[1,2],1,2,1,2,3,4,5,6] //count:9 splice()splice() 方法向数组中添加项目(或 向数组中添加项目)，然后返回被删除的项目，返回值为数组。 一句话概括一下：此方法不是单纯的添加或者删除数组中的项，更像是更改数组。从索引为index的项开始（包括index项）往后面找个数length的项，将他们替换为item1…itemX 1语法：arrayObject.splice(index,length,item1,.....,itemX) 参数 描述 index 必填。规定添加（删除）的位置。即从索引为index的项为起点。如果为负数则从倒数项开始。 length 必填。规定删除的项的个数，如果为0则不删除。 item1…itemX 选填。规定添加的项。如果有item1…itemX，则不论是否删除，item1…itemX都会添加到数组。 例子1234567var arr = [1,2,3,4,5,6];var items = arr.splice(5,1); //arr:[1,2,3,4,5] 此用法表现为删除操作 //items:[6] 返回被删除的项var items = arr.splice(4,1,7,8,9); //arr:[1,2,3,4,7,8,9] 此用法表现为更改操作。从第index为4的项开始的1项删除，并插入 7，8，9 //count:[5] 返回被删除的项 reverse()reverse() 方法用于颠倒数组中元素的顺序，无返回值。 例子123var arr = [a,b,c,d];arr.reverse(); //arr:[d,c,b,a] sort()sort() 方法用于对数组的元素进行排序，无返回值。 例子123456789var arr = [1,5,3,2,4];arr.sort(); //arr:[1,2,3,4,5] 完成排序//但是注意，该方法仅用于对数组项为单纯数字的数组进行排序，如果数组的项为字符串，结果可能不为预期var strArr = ['1','12','2','5','300'];strArr.sort(); //strArr:['1','12','2','300','5'] 2）不会改变原数组的操作concat()concat() 方法用于两个或多个数组的拼接,返回值为拼接后的新数组。 1语法： arr1.concat(arr2,arr3...arrX); 其中arr2...arrX可以是具体的项 例子12345var arr1 = [1,2,3];var arr2 = arr1.concat(4,5); //arr2 = [1,2,3,4,5]var arr3 = arr1.concat([4,5]); //arr3 = [1,2,3,4,5] //arr1 = [1,2,3] -- 不改变原数组 &nbsp;&nbsp; 以上两个操作拼接的为不同对象，但结果是一样的，由此看出concat()方法返回值有且只有一个数组。如果传入参数为数组，会将数组的每个项拆分再进行拼接操作。 *tips:因concat()不会改变任何数组就能复制出一个与原数组一摸一样的数组，所以多用来对数组进行深拷贝操作 var arr1 = [1,2,3]; var arr2 = [].concat(arr1); //将arr1的值与空数组拼接，意在将arr1的值复制一份。]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
        <tag>js数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first article]]></title>
    <url>%2F2019%2F09%2F04%2Fmy-first-article%2F</url>
    <content type="text"><![CDATA[lalalalalalal 这是一级标题这是二级标题这是三级标题 感谢人生中每一位老师 这是粗体 这不是粗体 百度 短发短发短发 https://www.baidu.com 我从来不梦想，我只是在努力认识现实；戏剧家洪深说：我的梦想是明年吃苦的能力比今年更强；鲁迅说：人生最大的痛苦是梦醒了无路可走；苏格拉底说：人类的幸福和欢乐在于奋斗，而最有价值的是为了理想而奋斗 在Js中通常使用console.log(&quot;&quot;)的方式在控制台打印数据 123function add(a,b) &#123; return a+b;//返回a与b相加的值&#125; 序号 名称 年龄 1 张三 18 2 李四 18 3 王五 18 语文 数学 英语 无序列表 首个title 二级title 有序列表 首个title 二级title 三级title]]></content>
      <categories>
        <category>测试文章</category>
      </categories>
  </entry>
</search>
